;;; **********************************************************************
;;; Copyright (C) 2003 Heinrich Taube (taube@uiuc.edu) 
;;; This program is free software; you can redistribute it and
;;; modify it under the terms of the GNU General Public License
;;; as published by the Free Software Foundation; either version 2
;;; of the License, or (at your option) any later version.
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;; **********************************************************************

;;; generated by scheme->cltl from objects.scm on 07-Jan-2007 08:09:00

(in-package :cm)

(defmethod copy-object ((obj t))
  (let ((new (make-instance (class-of obj))))
    (fill-object new obj)
    new))

(defmethod fill-object ((new t) (old t))
  (dolist (s (closer-mop:class-slots (class-of old)))
    (let ((n (closer-mop:slot-definition-name s)))1
      (when (and (slot-exists-p new n) (slot-boundp old n))
        (setf (slot-value new n) (slot-value old n))))))

(defun save-object (obj file)
  (let ((fp nil))
    (unwind-protect
        (progn (setf fp (open-file file :output))
               (if (consp obj)
                   (dolist (o obj)
                     (write (make-load-form o) :stream fp))
                   (write (make-load-form obj) :stream fp)))
      (if fp (close-file fp :output)))
    file))

(defparameter *dictionary* (make-hash-table :size 31 :test #'equal))

(defclass container ()
         ((name :initform nil :accessor object-name :initarg :name)))

(defmethod print-object ((obj container) port)
  (let ((name (object-name obj)) (*print-case* ':downcase))
    (if name
        (format port "#<~a \"~a\">" (class-name (class-of obj)) name)
        (call-next-method))))

;; TODO This really isn't needed. Do this properly
(defmethod initialize-instance :after ((obj container)
                                       &rest
                                       args) args (let
                                                   ((name
                                                     (object-name
                                                      obj)))
                                                   (when
                                                    name
                                                    (unless
                                                     (stringp name)
                                                     (if
                                                      (and
                                                       name
                                                       (symbolp
                                                        name))
                                                      (setf
                                                       name
                                                       (string-downcase
                                                        (symbol-name
                                                         name)))
                                                      (setf
                                                       name
                                                       (format
                                                        nil
                                                        "~a"
                                                        name)))
                                                     (setf
                                                      (object-name
                                                       obj)
                                                      name))
                                                    (setf
                                                     (gethash
                                                      (string-downcase
                                                       name)
                                                      *dictionary*)
                                                     obj))
                                                   (values)))

(defmethod make-load-form ((obj container))
  `(make-instance
     ,(intern (string-upcase
                (format nil "<~a>" (class-name (class-of obj))))
              :cm)
     ,@(slot-init-forms obj :eval t :omit '(subobjects))
     :subobjects
     ,(cons 'list
            (mapcar #'make-load-form (container-subobjects obj)))))

;; TODO look at as part of *dictionary* sanitizing
(defmethod rename-object ((obj container) newname &rest args)
  (let* ((err? (if (null args) t (car args)))
         (str
          (if (stringp newname) newname (format nil "~a" newname)))
         (old (find-object str)))
    (if old
        (if (eq obj old)
            old
            (if err?
                (error "The name ~a already references ~s."
                       newname
                       old)
                nil))
        (progn (remhash (object-name obj) *dictionary*)
               (setf (object-name obj) str)
               (setf (gethash (string-downcase str) *dictionary*)
                     obj)
               obj))))

(defun list-named-objects (&optional type)
  (hash-fold
   (if type
       (lambda (k v p) k (if (typep v type) (cons v p) p))
       (lambda (k v p) k (cons v p)))
   '() *dictionary*))

(defun find-object (string &optional err? class)
  (let* ((name (if (stringp string) string (format nil "~a" string)))
         (type (filename-type name))
         (find nil))
    (if (not type)
        (setf find (gethash (string-downcase name) *dictionary*))
        (let ((name (filename-name name))
              (path (filename-directory name)))
          (hash-fold
           (lambda (k val res)
             k
             res
             (when t
               (let* ((key (object-name val))
                      (typ (filename-type key)))
                 (if typ
                     (let ((nam (filename-name key))
                           (dir (or (filename-directory key) "")))
                       (if (and (string= type typ)
                                (string= name nam)
                                (or (not path) (string= path dir)))
                           (if find
                               (error
                                "More than one file named ~S."
                                string)
                               (setf find val)))))))
             nil)
           nil *dictionary*)))
    (when (and class find)
      (unless (typep find class) (setf find nil)))
    (or find (if err? (error "No object named ~s." string) nil))))

(read-macro-set! #\& (lambda (form) `(find-object ',form t)))

 (defclass seq (container)
         ((time :accessor object-time :initarg :time :initform 0)
          (subobjects :initform '() :accessor container-subobjects
           :initarg :subobjects)))

(defmethod subcontainers ((obj standard-object)) obj '())

(defmethod subcontainers ((obj seq))
  (loop for o in (container-subobjects obj)
        when (typep o 'container) collect o))

(defun map-objects (fn objs &key (start 0) end (step 1) (width 1) at
                    test class key slot slot! arg2 &aux doat indx
                    this)
  (if (not (listp objs)) (setf objs (container-subobjects objs)))
  (if (and slot slot!)
      (error ":slot and slot! are exclusive keywords."))
  (when (or slot slot!)
    (if key
        (error ":slot[!] and :key are exclusive keywords.")
        (setf key
              (if slot!
                  (lambda (x) (slot-value x slot!))
                  (lambda (x) (slot-value x slot))))))
  (when at
    (unless (and (eq start 0) (not end) (eq step 1))
      (error ":at excludes use of :start step and :end"))
    (unless (apply #'< at)
      (error ":at values not in increasing order."))
    (setf doat t)
    (setf start (pop at)))
  (setf indx start)
  (do ((tail (nthcdr start objs) (nthcdr step tail))
       (data nil)
       (done nil)
       (func
        (cond ((not arg2) fn)
              ((eq arg2 ':object) (lambda (x) (funcall fn x this)))
              ((eq arg2 ':position) (lambda (x) (funcall fn x indx)))
              (t (error ":arg2 not :object or :position")))))
      ((or (null tail) done (and end (not (< indx end)))) (values))
    (cond ((> width 1)
           (setf this
                 (loop for i below width
                       for x = (nthcdr i tail)
                       until (null x)
                       collect (car x)))
                 (when (or (not class)
                           (loop for x in this
                                 always (typep x class)))
                           (if key
                               (setf data (mapcar key this))
                               (setf data this))
                           (if (or
                                (not test)
                                (loop for x in data
                                 always (funcall test x)))
                                (if
                                 slot!
                                 (loop for x in (funcall func data)
                                  for y in this
                                  do (setf (slot-value y slot!) x))
                                  (funcall func data)))))
                           (t
                            (setf this (car tail))
                            (when (or (not class) (typep this class))
                              (if
                               key
                               (setf data (funcall key this))
                               (setf data this))
                              (if
                               (or (not test) (funcall test data))
                               (if
                                slot!
                                (setf
                                 (slot-value this slot!)
                                 (funcall func data))
                                (funcall func data))))))
                   (when doat
                     (if (null at)
                         (progn (setf done t) (setf step 0))
                         (progn (setf step (- (pop at) indx)))))
                   (setf indx (+ indx step))))

(defun fold-objects (fn objects acc &rest args)
  (apply #'map-objects
         (lambda (x) (setf acc (funcall fn x acc)))
         objects
         args)
  acc)

(defun subobjects (object &rest args)
  (if (null args)
      (container-subobjects object)
      (let* ((head (list nil)) (tail head))
        (if (member ':slot! args)
            (error "Illegal keyword argument :slot!"))
        (apply #'map-objects
               (lambda (a x)
                 a
                 (rplacd tail (list x))
                 (setf tail (cdr tail)))
               object
               :arg2
               ':object
               args)
        (cdr head))))

(defun list-objects (object &rest args)
  (apply #'map-objects
         (lambda (x i) (format t "~d. ~s~%" i x))
         object
         :arg2
         ':position
         args))

(defmethod insert-object ((sub standard-object) (obj seq))
  (let ((subs (container-subobjects obj)))
    (if (null subs)
        (let ((l (list sub))) (setf (container-subobjects obj) l) l)
        (let ((time (object-time sub)))
          (cond ((< time (object-time (car subs)))
                 (let ((l (cons sub subs)))
                   (setf (container-subobjects obj) l)
                   l))
                (t
                 (do ((top subs) (head (cdr subs) (cdr subs)))
                     ((or (null head)
                          (not (<= (object-time (car head)) time)))
                      (rplacd subs (cons sub head))
                      top)
                   (setf subs head))))))))

(defmethod append-object ((sub standard-object) (obj seq))
  (let ((subs (container-subobjects obj)))
    (cond ((null subs)
           (setf subs (list sub))
           (setf (container-subobjects obj) subs))
          (t (rplacd (last subs) (list sub))))
    subs))

(defmethod remove-object (sub (obj seq))
  (let ((subs (container-subobjects obj)))
    (unless (null subs)
      (if (eq sub (car subs))
          (progn (setf subs (cdr subs))
                 (setf (container-subobjects obj) subs))
          (do ((prev subs) (tail (cdr subs) (cdr tail)))
              ((or (null tail) (eq sub (car tail)))
               (rplacd prev (cddr prev)))
            (setf prev tail))))
    subs))

(defmethod remove-subobjects ((obj seq))
  (setf (container-subobjects obj) (list)))

(defclass event ()
         ((time :accessor object-time :initarg :time)))

(defparameter *print-event* t)

(defmethod print-object ((obj event) port)
  (if *print-event*
      (let ((class (class-of obj)) (*print-case* ':downcase))
        (format port "#i(~a" (class-name class))
        (do ((slots (closer-mop:class-slots class) (cdr slots))
             (d nil)
             (s nil)
             (v nil)
             (k nil))
            ((null slots) nil)
          (setf d (car slots))
          (setf s (closer-mop:slot-definition-name d))
          (if (slot-boundp obj s)
              (progn (setf v (slot-value obj s))
                     (setf k (closer-mop:slot-definition-initargs d))
                     (unless (null k)
                       (unless (and
                                (eq *print-event* ':terse)
                                (eq v (closer-mop:slot-definition-initform d)))
                         (format port " ~a ~s" s v))))))
        (format port ")")
        obj)
      (call-next-method)))

(serapeum:defalias new 'make-instance)

(defun class-name->class-var (sym)
  (let ((str (symbol-name sym)))
    (if (char= (elt str 0) #\<)
        sym
        (intern (string-upcase (concatenate 'string "<" str ">"))
                :cm))))

(defun class-var->class-name (sym)
  (let ((str (symbol-name sym)))
    (if (char= #\< (elt str 0))
        (intern (string-upcase (subseq str 1 (- (length str) 1)))
                :cm)
        (error "Class variable not <~a>" sym))))


(defun write-event-streams (lst)
  (error "sorry, it's not support."))

