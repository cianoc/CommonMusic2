;;; **********************************************************************
;;; Copyright (C) 2003 Heinrich Taube (taube@uiuc.edu) 
;;; This program is free software; you can redistribute it and
;;; modify it under the terms of the GNU General Public License
;;; as published by the Free Software Foundation; either version 2
;;; of the License, or (at your option) any later version.
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;; **********************************************************************

;;; generated by scheme->cltl from utils.scm on 07-Jan-2007 08:09:00

(in-package :cm)

(defmacro make-cycl () `(make-list 2))

(defmacro cycl-data (cycl) `(car ,cycl))

(defmacro cycl-data-set! (cycl data) `(rplaca ,cycl ,data))

(defmacro cycl-last (cycl) `(cadr ,cycl))

(defmacro cycl-last-set! (cycl data) `(rplaca (cdr ,cycl) ,data))

(defmacro cycl-tail (cycl) `(cddr ,cycl))

(defmacro cycl-tail-set! (cycl tail) `(rplacd (cdr ,cycl) ,tail))

(defmacro pop-cycl (cycl) `(pop (cdr (cdr ,cycl))))

(defmacro reset-cycl (cycl)
  (let ((c (gensym)))
    `(let ((,c ,cycl)) (cycl-tail-set! ,c (car ,c)))))


(defun quote-if-necessary (x)
  (if (or (numberp x)
          (stringp x)
          (vectorp x)
          (and (consp x) (eq (car x) 'quote)))
      x
      `',x))

(defun parse-lambda-list (pars)
  (flet ((bind (par type maxlen)
           (if (consp par)
               (progn (if (eq type '&key)
                          (cond ((consp (car par))
                                 (unless
                                  (and
                                   (keyword? (car (car par)))
                                   (= (length (car par)) 2)
                                   (let
                                    ((t1 (cadr (car par))))
                                    (and t1 (symbolp t1))))
                                  (error
                                   "Malformed ~s parameter: ~s"
                                   type
                                   par)))
                                ((let
                                  ((t2 (car par)))
                                  (and t2 (symbolp t2)))
                                 t)
                                (t
                                 (error
                                  "Malformed ~s parameter: ~s."
                                  type
                                  par)))
                          (unless (let
                                   ((t3 (car par)))
                                   (and t3 (symbolp t3)))
                            (error "Malformed ~s parameter: ~s."
                                   type
                                   par)))
                      (unless (<= (length par) maxlen)
                        (error "Malformed ~s parameter: ~s."
                               type
                               par))
                      par)
               (if (and par (symbolp par))
                   (list par nil)
                   (error "Not a lambda parameter: ~s." par)))))
    (let ((mode '&required)
          (reqs '())
          (opts '())
          (rest '())
          (keys '())
          (auxs '())
          (aok? nil)
          (this nil)
          (head pars))
      (do ()
          ((null pars))
        (setf this (car pars))
        (setf pars (cdr pars))
        (if (member this
                    '(&optional &rest &key &aux &allow-other-keys))
            (cond ((eq this '&optional)
                   (unless (eq mode '&required)
                     (error "Malformed lambda list: ~s." head))
                   (setf mode '&optional))
                  ((eq this '&rest)
                   (unless (member mode '(&required &optional))
                     (error "Malformed lambda list: ~s." head))
                   (setf mode '&rest))
                  ((eq this '&key)
                   (unless (member mode '(&required &optional !rest))
                     (error "Malformed lambda list: ~s." head))
                   (setf mode '&key))
                  ((eq this '&allow-other-keys)
                   (unless (eq mode '&key)
                     (error "Malformed lambda list: ~s." head))
                   (setf mode '&allow-other-keys)
                   (setf aok? t))
                  ((eq this '&aux) (setf mode '&aux)))
            (case mode
              ((&required)
               (if (not (and this (symbolp this)))
                   (error "Required argument not symbol: ~s" this))
               (push this reqs))
              ((&optional) (push (bind this mode 3) opts))
              ((&rest)
               (if (not (and this (symbolp this)))
                   (error "&rest argument not symbol: ~s" this))
               (push this rest) (setf mode '!rest))
              ((&key) (push (bind this mode 3) keys))
              ((&aux) (push (bind this mode 2) auxs))
              (t (error "Malformed lambda list: ~s." head)))))
      (values (reverse reqs)
              (reverse opts)
              rest
              (reverse keys)
              aok?
              (reverse auxs)))))


(defun string-substrings (string &key (delimiters '(#\  #\Tab))
                          (start 0) (end (length string)) key)
  (let* ((pos1 start) (pos2 nil) (head (list nil)) (tail head))
    (do ()
        ((> pos1 end) (cdr head))
      (setf pos2
            (or (do ((i pos1 (+ i 1)) (f nil))
                    ((or f (= i end)) f)
                  (if (member (elt string i) delimiters) (setf f i)))
                end))
      (unless (= pos1 pos2)
        (rplacd tail
                (list (if key
                          (funcall key (subseq string pos1 pos2))
                          (subseq string pos1 pos2))))
        (setf tail (cdr tail)))
      (setf pos1 (+ pos2 1)))))

(defun string-readable? (string &optional (start 0)
                         (end (length string)))
  (do ((pos start (+ pos 1))
       (tok nil)
       (num 0)
       (lev 0)
       (str nil)
       (chr nil))
      ((not (< pos end))
       (if (and (= pos end) (= lev 0) (not str))
           (if tok (+ num 1) num)
           nil))
    (setf chr (elt string pos))
    (cond ((char= chr #\()
           (if (= lev 0) (incf num))
           (incf lev)
           (setf tok nil))
          ((char= chr #\))
           (decf lev)
           (if (< lev 0) (setf pos end))
           (setf tok nil))
          ((char= chr #\")
           (setf str (not str))
           (if (and (= lev 0) str) (incf num))
           (setf tok nil))
          ((member chr '(#\, #\`)) (if (not str) (setf pos end)))
          ((member chr '(#\  #\Return #\Tab))
           (if (and tok (= lev 0) (not str)) (incf num))
           (setf tok nil))
          ((member chr '(#\' #\#)) (setf tok nil))
          (t (setf tok t)))))

(defparameter +se-nullstring+ 0)

(defparameter +se-unreadable+ 1)

(defparameter +se-multiple+ 2)

(defparameter +se-incorrect+ 3)

(defparameter +se-not-number+ 4)

(defparameter +se-not-symbol+ 5)

(defparameter +se-not-cons+ 6)

(defun string->expr (str &key (read t) (test nil) (nullok t)
                     (multiok nil) errval)
  (let ((text str)
        (trim '(#\  #\Newline #\Tab))
        (expr nil)
        (err? nil))
    (if (string= text "")
        (if nullok (values nil nil) (values "" +se-nullstring+))
        (let ((len (length text)) (raw text))
          (if (or (member (elt text 0) trim)
                  (member (elt text (- len 1)) trim))
              (setf text (strip-chars text)))
          (if (string= text "")
              (if nullok
                  (values nil nil)
                  (values raw +se-nullstring+))
              (progn (if (not read)
                         (progn (setf expr text) (setf err? nil))
                         (if (not (eq read t))
                             (multiple-value-setq
                              (expr err?)
                              (funcall read text))
                             (let
                              ((num (string-readable? text)))
                              (cond
                               ((not num)
                                (setf expr text)
                                (setf err? +se-unreadable+))
                               ((= num 1)
                                (multiple-value-setq
                                 (expr num)
                                 (string-read text))
                                (setf err? nil))
                               ((not multiok)
                                (setf expr text)
                                (setf err? +se-multiple+))
                               (t
                                (do
                                 ((n 0) (x nil) (l (list)))
                                 ((eq x ':eof)
                                  (setf expr (nreverse l))
                                  (setf err? nil))
                                 (multiple-value-setq
                                  (x n)
                                  (string-read text n))
                                 (unless
                                  (eq x ':eof)
                                  (push x l))))))))
                     (if err?
                         (values expr err?)
                         (if test
                             (if
                              (funcall test expr)
                              (values expr nil)
                              (values
                               test
                               (or errval +se-incorrect+)))
                             (values expr err?)))))))))

